(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[9344],{3905:function(e,t,a){"use strict";a.d(t,{Zo:function(){return c},kt:function(){return m}});var n=a(7294);function l(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function r(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function i(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?r(Object(a),!0).forEach((function(t){l(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):r(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function o(e,t){if(null==e)return{};var a,n,l=function(e,t){if(null==e)return{};var a,n,l={},r=Object.keys(e);for(n=0;n<r.length;n++)a=r[n],t.indexOf(a)>=0||(l[a]=e[a]);return l}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(n=0;n<r.length;n++)a=r[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(l[a]=e[a])}return l}var p=n.createContext({}),s=function(e){var t=n.useContext(p),a=t;return e&&(a="function"==typeof e?e(t):i(i({},t),e)),a},c=function(e){var t=s(e.components);return n.createElement(p.Provider,{value:t},e.children)},u={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},d=n.forwardRef((function(e,t){var a=e.components,l=e.mdxType,r=e.originalType,p=e.parentName,c=o(e,["components","mdxType","originalType","parentName"]),d=s(a),m=l,k=d["".concat(p,".").concat(m)]||d[m]||u[m]||r;return a?n.createElement(k,i(i({ref:t},c),{},{components:a})):n.createElement(k,i({ref:t},c))}));function m(e,t){var a=arguments,l=t&&t.mdxType;if("string"==typeof e||l){var r=a.length,i=new Array(r);i[0]=d;var o={};for(var p in t)hasOwnProperty.call(t,p)&&(o[p]=t[p]);o.originalType=e,o.mdxType="string"==typeof e?e:l,i[1]=o;for(var s=2;s<r;s++)i[s]=a[s];return n.createElement.apply(null,i)}return n.createElement.apply(null,a)}d.displayName="MDXCreateElement"},5047:function(e,t,a){"use strict";a.r(t),a.d(t,{frontMatter:function(){return i},metadata:function(){return o},toc:function(){return p},default:function(){return c}});var n=a(2122),l=a(9756),r=(a(7294),a(3905)),i={sidebar_label:"module_interface",title:"core.module_interface"},o={unversionedId:"reference/core/module_interface",id:"reference/core/module_interface",isDocsHomePage:!1,title:"core.module_interface",description:"Module Interface module:",source:"@site/docs/reference/core/module_interface.md",sourceDirName:"reference/core",slug:"/reference/core/module_interface",permalink:"/PyMarlin/docs/reference/core/module_interface",editUrl:"https://github.com/microsoft/PyMarlin/edit/master/website/docs/reference/core/module_interface.md",version:"current",sidebar_label:"module_interface",frontMatter:{sidebar_label:"module_interface",title:"core.module_interface"},sidebar:"referenceSideBar",previous:{title:"core.data_interface",permalink:"/PyMarlin/docs/reference/core/data_interface"},next:{title:"core.trainer",permalink:"/PyMarlin/docs/reference/core/trainer"}},p=[{value:"Stage Objects",id:"stage-objects",children:[]},{value:"CallbackInterface Objects",id:"callbackinterface-objects",children:[]},{value:"ModuleInterface Objects",id:"moduleinterface-objects",children:[]}],s={toc:p};function c(e){var t=e.components,a=(0,l.Z)(e,["components"]);return(0,r.kt)("wrapper",(0,n.Z)({},s,a,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Module Interface module:"),(0,r.kt)("p",null,"This module contains the abstract classes CallbackInterface and\nModuleInterface that can provide everything necessary for model\ntraining. Users should implement these abstract classes in their\nScenarios."),(0,r.kt)("h2",{id:"stage-objects"},"Stage Objects"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},"class Stage(enum.Enum)\n")),(0,r.kt)("p",null,"Stages: train, val, test"),(0,r.kt)("h2",{id:"callbackinterface-objects"},"CallbackInterface Objects"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},"class CallbackInterface(ABC)\n")),(0,r.kt)("p",null,"A callback class used to add scenario specific outputs/logging/debugging during training."),(0,r.kt)("h4",{id:"on_begin_train_epoch"},"on","_","begin","_","train","_","epoch"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},"def on_begin_train_epoch(global_step: int, epoch: int)\n")),(0,r.kt)("p",null,"Hook before training epoch (before model forward)."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Arguments"),":"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"global_step")," ",(0,r.kt)("em",{parentName:"li"},"int")," - ","[description]"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"epoch")," ",(0,r.kt)("em",{parentName:"li"},"int")," - Current training epoch")),(0,r.kt)("h4",{id:"on_end_train_step"},"on","_","end","_","train","_","step"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},"def on_end_train_step(global_step: int, *train_step_collated_outputs)\n")),(0,r.kt)("p",null,"Runs after end of a global training step."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Arguments"),":"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"global_step")," ",(0,r.kt)("em",{parentName:"li"},"int")," - current global step"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"train_step_collated_outputs")," ",(0,r.kt)("em",{parentName:"li"},"list")," - all train step outputs in a list.\nIf train_step returns loss, logits train_step_collated_outputs will have ","[loss_collated, logits_collated]")),(0,r.kt)("h4",{id:"on_end_train_epoch"},"on","_","end","_","train","_","epoch"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},"def on_end_train_epoch(global_step: int, *train_step_collated_outputs)\n")),(0,r.kt)("p",null,"Hook after training epoch."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Arguments"),":"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"global_step")," ",(0,r.kt)("em",{parentName:"li"},"int")," - ","[description]"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"train_step_collated_outputs")," ",(0,r.kt)("em",{parentName:"li"},"list")," - all train step outputs in a list.\nIf train_step returns loss, logits train_step_collated_outputs will have ","[loss_collated, logits_collated]")),(0,r.kt)("h4",{id:"on_end_backward"},"on","_","end","_","backward"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},"def on_end_backward(global_step: int, loss_tensor)\n")),(0,r.kt)("p",null,"Hook after each backward"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Arguments"),":"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"global_step")," ",(0,r.kt)("em",{parentName:"li"},"int")," - ","[description]"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"loss_tensor(torch.Tensor)")," - Undetached loss tensor")),(0,r.kt)("h4",{id:"on_end_val_epoch"},"on","_","end","_","val","_","epoch"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},'def on_end_val_epoch(global_step: int, *val_step_collated_outputs, *, key="default")\n')),(0,r.kt)("p",null,"Update value at end of end of end of variable"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Arguments"),":"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"global_step")," ",(0,r.kt)("em",{parentName:"li"},"int")," - ","[description]","\nval_step_collated_outputs : all val step outputs in a list.\nIf val_step returns loss, logits train_step_collated_outputs will have ","[loss_collated, logits_collated]"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"key")," ",(0,r.kt)("em",{parentName:"li"},"str, optional")," - The id of the validation dataloader.\nDefaults to ",'"',"default",'"',".")),(0,r.kt)("h4",{id:"on_end_train"},"on","_","end","_","train"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},"def on_end_train(global_step: int)\n")),(0,r.kt)("p",null,"Hook after training finishes"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Arguments"),":"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"global_step")," ",(0,r.kt)("em",{parentName:"li"},"int")," - ","[description]")),(0,r.kt)("h2",{id:"moduleinterface-objects"},"ModuleInterface Objects"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},"class ModuleInterface(torch.nn.Module,  CallbackInterface)\n")),(0,r.kt)("p",null,"Interface for PyTorch modules."),(0,r.kt)("p",null,"This interface contains model architecture in the form of a PyTorch\n",(0,r.kt)("inlineCode",{parentName:"p"},"nn.Module")," together with optimizers and schedules, train and validation\nstep recipes and any callbacks."),(0,r.kt)("p",null,"Note: The forward function is overridden."),(0,r.kt)("p",null,"Note: Users are encouraged to override the ",(0,r.kt)("inlineCode",{parentName:"p"},"train_step")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"val_step"),"\nmethods."),(0,r.kt)("h4",{id:"get_optimizers_schedulers"},"get","_","optimizers","_","schedulers"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},"@abstractmethod\ndef get_optimizers_schedulers(estimated_global_steps_per_epoch: int, epochs: int) -> Tuple[Iterable[torch.optim.Optimizer], Iterable]\n")),(0,r.kt)("p",null,"Returns a list of optimizers and schedulers\nthat are used to instantiate the optimizers ."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Returns"),":"),(0,r.kt)("p",null,"  Tuple[Iterable","[torch.optim.Optimizer]",", Iterable]:\nlist of optimizers and list of schedulers"),(0,r.kt)("h4",{id:"get_train_dataloader"},"get","_","train","_","dataloader"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},"@abstractmethod\ndef get_train_dataloader(sampler: type, batch_size: int) -> torch.utils.data.DataLoader\n")),(0,r.kt)("p",null,"Returns a dataloader for the training loop .\nCalled every epoch."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Arguments"),":"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"sampler")," ",(0,r.kt)("em",{parentName:"li"},"type")," - data sampler type which is a derived class of torch.utils.data.Sampler\nCreate concrete sampler object before creating dataloader."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"batch_size")," ",(0,r.kt)("em",{parentName:"li"},"int")," - batch size per step per device")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Returns"),":"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"torch.utils.data.DataLoader")," - Training dataloader")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Example"),":"),(0,r.kt)("p",null,"  train_ds = self.data.get_train_dataset()\ndl = DataLoader(train_ds, batch_size = batch_size, collate_fn= self.collate_fin, sampler = sampler(train_ds))\nreturn dl"),(0,r.kt)("h4",{id:"get_val_dataloaders"},"get","_","val","_","dataloaders"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},"@abstractmethod\ndef get_val_dataloaders(sampler: torch.utils.data.Sampler, batch_size: int) -> Union[\n        Dict[str, torch.utils.data.DataLoader],\n        torch.utils.data.DataLoader\n    ]\n")),(0,r.kt)("p",null,"Returns dataloader(s) for validation loop .\nSupports multiple dataloaders based on key value.\nKeys will be passed in the callback functions.\nCalled every epoch ."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Arguments"),":"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"sampler")," ",(0,r.kt)("em",{parentName:"li"},"type")," - data sampler type which is a derived class of torch.utils.data.Sampler\nCreate concrete sampler object before creating dataloader."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"batch_size")," ",(0,r.kt)("em",{parentName:"li"},"int")," - validation batch size per step per device")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Returns"),":"),(0,r.kt)("p",null,"  Union[ Dict","[str, torch.utils.data.DataLoader]",",\ntorch.utils.data.DataLoader ]:\nA single dataloader or a dictionary of dataloaders\nwith key as the data id and value as dataloader"),(0,r.kt)("h4",{id:"get_test_dataloaders"},"get","_","test","_","dataloaders"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},"def get_test_dataloaders(sampler, batch_size)\n")),(0,r.kt)("p",null,"Returns test dataloaders"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Arguments"),":"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"sampler")," ",(0,r.kt)("em",{parentName:"li"},"[type]")," - ","[description]"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"batch_size")," ",(0,r.kt)("em",{parentName:"li"},"[type]")," - ","[description]")),(0,r.kt)("h4",{id:"forward"},"forward"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},"def forward(stage: Stage, global_step: int, batch, device: Union[torch.device, str, int])\n")),(0,r.kt)("p",null,"torch.nn.Module","'","s forward() function.\nOverridden to call train_step() or val_step() based on stage ."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Arguments"),":"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"stage")," ",(0,r.kt)("em",{parentName:"li"},"Stage")," - trian/val/test"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"global_step")," ",(0,r.kt)("em",{parentName:"li"},"int")," - current global step"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"batch")," ",(0,r.kt)("em",{parentName:"li"},"[type]")," - output of dataloader step"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"device")," ",(0,r.kt)("em",{parentName:"li"},"Union","[torch.device, str, int]")," - device")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Raises"),":"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"AttributeError")," - if stage is different than train, val, test")),(0,r.kt)("h4",{id:"train_step"},"train","_","step"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},"@abstractmethod\ndef train_step(global_step: int, batch, device: Union[torch.device, str, int]) -> Union[torch.Tensor, Tuple]\n")),(0,r.kt)("p",null,"Train a single train step .\nBatch should be moved to device before any operation."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Arguments"),":"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"global_step")," ",(0,r.kt)("em",{parentName:"li"},"int")," - ","[description]"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"batch")," ",(0,r.kt)("em",{parentName:"li"},"[type]")," - output of train dataloader step"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"device")," ",(0,r.kt)("em",{parentName:"li"},"Union","[torch.device, str, int]")," - device")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Returns"),":"),(0,r.kt)("p",null,"  Union[torch.Tensor, Iterable","[torch.Tensor]","]:\nThe first return value must be the loss tensor.\nCan return more than one values in output. All outputs must be tensors\nCallbacks will collate all outputs."),(0,r.kt)("h4",{id:"val_step"},"val","_","step"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},"@abstractmethod\ndef val_step(global_step: int, batch, device) -> Tuple\n")),(0,r.kt)("p",null,"Runs a single Validation step ."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Arguments"),":"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"global_step")," ",(0,r.kt)("em",{parentName:"li"},"int")," - ","[description]"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"batch")," ",(0,r.kt)("em",{parentName:"li"},"[type]")," - ","[description]"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"device")," ",(0,r.kt)("em",{parentName:"li"},"[type]")," - ","[description]")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Returns"),":"),(0,r.kt)("p",null,"  Union[torch.Tensor, Iterable","[torch.Tensor]","]: values that need to be collected - loss, logits etc.\nAll outputs must be tensors"),(0,r.kt)("h4",{id:"test_step"},"test","_","step"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},"def test_step(global_step: int, batch, device)\n")),(0,r.kt)("p",null,"Runs a single test step ."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Arguments"),":"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"global_step")," ",(0,r.kt)("em",{parentName:"li"},"int")," - ","[description]"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"batch")," ",(0,r.kt)("em",{parentName:"li"},"[type]")," - ","[description]"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"device")," ",(0,r.kt)("em",{parentName:"li"},"[type]")," - ","[description]")),(0,r.kt)("h4",{id:"get_state"},"get","_","state"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},"def get_state()\n")),(0,r.kt)("p",null,"Get the current state of the module, used for checkpointing."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Returns"),":"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"Dict")," - Dictionary of variables or objects to checkpoint.")),(0,r.kt)("h4",{id:"update_state"},"update","_","state"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},"def update_state(state: Dict)\n")),(0,r.kt)("p",null,"Update the module from a checkpointed state."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Arguments"),":"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"state")," ",(0,r.kt)("em",{parentName:"li"},"Dict")," - Output of get_state() during checkpointing.")))}c.isMDXComponent=!0}}]);
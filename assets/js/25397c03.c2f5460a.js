(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[5666],{3905:function(e,t,n){"use strict";n.d(t,{Zo:function(){return p},kt:function(){return k}});var a=n(7294);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function l(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function r(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?l(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):l(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function o(e,t){if(null==e)return{};var n,a,i=function(e,t){if(null==e)return{};var n,a,i={},l=Object.keys(e);for(a=0;a<l.length;a++)n=l[a],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(e);for(a=0;a<l.length;a++)n=l[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var s=a.createContext({}),c=function(e){var t=a.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):r(r({},t),e)),n},p=function(e){var t=c(e.components);return a.createElement(s.Provider,{value:t},e.children)},d={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},u=a.forwardRef((function(e,t){var n=e.components,i=e.mdxType,l=e.originalType,s=e.parentName,p=o(e,["components","mdxType","originalType","parentName"]),u=c(n),k=i,h=u["".concat(s,".").concat(k)]||u[k]||d[k]||l;return n?a.createElement(h,r(r({ref:t},p),{},{components:n})):a.createElement(h,r({ref:t},p))}));function k(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var l=n.length,r=new Array(l);r[0]=u;var o={};for(var s in t)hasOwnProperty.call(t,s)&&(o[s]=t[s]);o.originalType=e,o.mdxType="string"==typeof e?e:i,r[1]=o;for(var c=2;c<l;c++)r[c]=n[c];return a.createElement.apply(null,r)}return a.createElement.apply(null,n)}u.displayName="MDXCreateElement"},9886:function(e,t,n){"use strict";n.r(t),n.d(t,{frontMatter:function(){return r},metadata:function(){return o},toc:function(){return s},default:function(){return p}});var a=n(2122),i=n(9756),l=(n(7294),n(3905)),r={sidebar_label:"checkpoint_utils",title:"utils.checkpointer.checkpoint_utils"},o={unversionedId:"reference/utils/checkpointer/checkpoint_utils",id:"reference/utils/checkpointer/checkpoint_utils",isDocsHomePage:!1,title:"utils.checkpointer.checkpoint_utils",description:"Checkpointer class and utility functions.",source:"@site/docs/reference/utils/checkpointer/checkpoint_utils.md",sourceDirName:"reference/utils/checkpointer",slug:"/reference/utils/checkpointer/checkpoint_utils",permalink:"/PyMarlin/docs/reference/utils/checkpointer/checkpoint_utils",editUrl:"https://github.com/microsoft/PyMarlin/edit/master/website/docs/reference/utils/checkpointer/checkpoint_utils.md",version:"current",sidebar_label:"checkpoint_utils",frontMatter:{sidebar_label:"checkpoint_utils",title:"utils.checkpointer.checkpoint_utils"},sidebar:"referenceSideBar",previous:{title:"plugins.plugin_module_interface",permalink:"/PyMarlin/docs/reference/plugins/plugin_module_interface"},next:{title:"utils.config_parser.custom_arg_parser",permalink:"/PyMarlin/docs/reference/utils/config_parser/custom_arg_parser"}},s=[{value:"Checkpoint Objects",id:"checkpoint-objects",children:[]},{value:"DefaultCheckpointerArguments Objects",id:"defaultcheckpointerarguments-objects",children:[]},{value:"AbstractCheckpointer Objects",id:"abstractcheckpointer-objects",children:[]},{value:"DefaultCheckpointer Objects",id:"defaultcheckpointer-objects",children:[]}],c={toc:s};function p(e){var t=e.components,n=(0,i.Z)(e,["components"]);return(0,l.kt)("wrapper",(0,a.Z)({},c,n,{components:t,mdxType:"MDXLayout"}),(0,l.kt)("p",null,"Checkpointer class and utility functions."),(0,l.kt)("h2",{id:"checkpoint-objects"},"Checkpoint Objects"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-python"},"@dataclass\nclass Checkpoint()\n")),(0,l.kt)("p",null,"Checkpoint data class that holds the states for\nmodule_interface, trainer and trainer_backend"),(0,l.kt)("h2",{id:"defaultcheckpointerarguments-objects"},"DefaultCheckpointerArguments Objects"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-python"},"@dataclass\nclass DefaultCheckpointerArguments()\n")),(0,l.kt)("p",null,"Default Checkpointer Arguments."),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Arguments"),":"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"checkpoint")," ",(0,l.kt)("em",{parentName:"li"},"bool")," - Flag indicating whether to checkpoint model when save()\nis called. Other conditions are implemented within save(), allowing this\nmethod to always be called within training loops and abstracting the\ncheckpointing logic out of Trainer and implemented in this class."),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"delete_existing_checkpoints")," ",(0,l.kt)("em",{parentName:"li"},"bool")," - Flag indicating whether to delete checkpoints\nunder save_dir before training. New checkpoints are saved regardless."),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"period")," ",(0,l.kt)("em",{parentName:"li"},"int")," - Period of index at which to checkpoint model. Evaluates\nindex % period == 0. This function is called with index set to the\nepoch, and thus checkpoints every ",'"',"period",'"'," number of epochs. The last\nepoch is always checkpointed regardless."),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"save_dir")," ",(0,l.kt)("em",{parentName:"li"},"str")," - Path to directory where checkpoints are to be stored. Creates\nfolder if it does not exist."),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"model_state_save_dir")," ",(0,l.kt)("em",{parentName:"li"},"str")," - Path to directory where checkpointed models are to\nbe stored. Creates folder if it does not exist."),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"load_dir")," ",(0,l.kt)("em",{parentName:"li"},"str")," - Path to directory where checkpoints are to be loaded from.\nIf not set, will not attempt to load a checkpoint. If load_filename\nis set, will search for this filename within the directory to load it.\nIf load_filename is not set, will load the file via get_latest_file()."),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"load_filename")," ",(0,l.kt)("em",{parentName:"li"},"str")," - Filename of checkpoint to load under load_dir, overrides\nautomatic loading via get_latest_file()."),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"file_prefix")," ",(0,l.kt)("em",{parentName:"li"},"str")," - Prefix of the checkpoint filename. Final filename to save\nwill be {file",(0,l.kt)("em",{parentName:"li"},"prefix}"),"{index}.{file",(0,l.kt)("em",{parentName:"li"},"ext}, or in the case of saving with\nsave_model(), {file_prefix}_mode"),"{index}.{file_ext}."),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"file_ext")," ",(0,l.kt)("em",{parentName:"li"},"str")," - File extension for the checkpoint filename when saving and when\nsearching under load_dir for loading via get_latest_file().\nWhen cleaning save_dir via delete_existing_checkpoints=True, only files\nwith this extension are considered."),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"log_level")," ",(0,l.kt)("em",{parentName:"li"},"str")," - Logging level for checkpointer module (Default: ","'","INFO","'",").")),(0,l.kt)("h2",{id:"abstractcheckpointer-objects"},"AbstractCheckpointer Objects"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-python"},"class AbstractCheckpointer(ABC)\n")),(0,l.kt)("p",null,"Abstract class for a checkpointer."),(0,l.kt)("p",null,"To create a custom checkpointer, users must implement the abstract\nmethods of this class and pass along an instance to ModuleInterface.\nCustom checkpointers can be used at other stages of the\ntraining lifecycle via callbacks."),(0,l.kt)("h4",{id:"save"},"save"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-python"},"@abstractmethod\ndef save(checkpoint_state: Checkpoint, index: int, force: Optional[bool]) -> None\n")),(0,l.kt)("p",null,"Creates a checkpoint by saving a Checkpoint dataclass containing any\nrelevant states."),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Arguments"),":"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"checkpoint_state")," ",(0,l.kt)("em",{parentName:"li"},"Checkpoint")," - Checkpointed states."),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"index")," ",(0,l.kt)("em",{parentName:"li"},"int")," - Using epoch as index is suggested."),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"force")," ",(0,l.kt)("em",{parentName:"li"},"bool, optional")," - Saves checkpoint regardless of conditions\nif args.checkpoint is set to True. Used to always checkpoint\nmodels after the last epoch.")),(0,l.kt)("h4",{id:"save_model"},"save","_","model"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-python"},"def save_model(model_state: Dict, index: int) -> None\n")),(0,l.kt)("p",null,"Creates a model checkpoint by saving model state."),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Arguments"),":"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"model_state")," ",(0,l.kt)("em",{parentName:"li"},"Dict")," - Model state as provided by ModuleInterface."),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"index")," ",(0,l.kt)("em",{parentName:"li"},"int")," - Number to use to create a unique filename.\nUsing epoch as index is suggested.")),(0,l.kt)("h4",{id:"load"},"load"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-python"},"@abstractmethod\ndef load() -> Checkpoint\n")),(0,l.kt)("p",null,"Load and return a checkpointed file."),(0,l.kt)("p",null,"Implements logic to load a checkpointed file as configured\nvia args used when constructing the checkpointer object. Always called\nupon initialization of Trainer."),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Returns"),":"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"Checkpoint")," - Checkpointed states.")),(0,l.kt)("h2",{id:"defaultcheckpointer-objects"},"DefaultCheckpointer Objects"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-python"},"class DefaultCheckpointer(AbstractCheckpointer)\n")),(0,l.kt)("p",null,"Default checkpointer implementation, implements AbstractCheckpointer and\ncontains a few helper functions for managing checkpointed files."),(0,l.kt)("p",null,"Must be initialized with DefaultCheckpointerArguments."),(0,l.kt)("h4",{id:"__init__"},"_","_","init","_","_"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-python"},"def __init__(args: DefaultCheckpointerArguments)\n")),(0,l.kt)("p",null,"Initialize checkpointer and delete existing checkpointed files\nunder save_dir if delete_existing_checkpoints is set to True."),(0,l.kt)("h4",{id:"save-1"},"save"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-python"},"def save(checkpoint_state: Checkpoint, index: int, force=False) -> str\n")),(0,l.kt)("p",null,"Creates a checkpoint by saving a Checkpoint dataclass containing any\nrelevant states as a python Dict."),(0,l.kt)("p",null,"Evaluates conditions and, if met, saves a provided dataclass\nwhich should contain any states that users require to save as\npart of a checkpoint under args.save_dir. An additional index\nargument is required to create a unique name for the file to be\nsaved. The optional force flag will disregard conditions other\nthan the checkpoint flag that enables this behavior. The condition\nfor saving with DefaultCheckpointer is index being a multiple\nof the args.period."),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Arguments"),":"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"checkpoint_state")," ",(0,l.kt)("em",{parentName:"li"},"Checkpoint")," - Checkpointed states."),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"index")," ",(0,l.kt)("em",{parentName:"li"},"int")," - Number to use to create a unique filename and\nevaluate conditions for checkpointing. Using epoch as index\nis suggested."),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"force")," ",(0,l.kt)("em",{parentName:"li"},"bool, optional")," - Saves checkpoint regardless of conditions\nif args.checkpoint is set to True. Used to always checkpoint\nstates after the last epoch.")),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Returns"),":"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"str")," - Path to checkpointed file.")),(0,l.kt)("h4",{id:"save_model-1"},"save","_","model"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-python"},"def save_model(model_state: Dict, index: int) -> str\n")),(0,l.kt)("p",null,"Checkpoints a model state, leveraging torch.save()."),(0,l.kt)("p",null,"Evaluates if checkpointing is enabled and if a model save directory\nhas been set, and saves a provided model state. An additional index\nargument is required to create a unique name for the file to be\nsaved."),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Arguments"),":"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"model_state")," ",(0,l.kt)("em",{parentName:"li"},"Dict")," - Model state as provided by ModuleInterface."),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"index")," ",(0,l.kt)("em",{parentName:"li"},"int")," - Number to use to create a unique filename.\nUsing epoch as index is suggested.")),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Returns"),":"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"str")," - Path to checkpointed file.")),(0,l.kt)("h4",{id:"load-1"},"load"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-python"},"def load() -> Checkpoint\n")),(0,l.kt)("p",null,"Attempt to load and return a checkpointed file leveraging torch.load().\nThe checkpoined file is assumed to be created with save() and thus be\na python Dict."),(0,l.kt)("p",null,"This method is always called upon initialization of Trainer.\nSearches for and attempts to load a checkpointed file based on\nargs. If no load_dir is set, returns None. If a load_dir and\nload_filename have been set, the file ",'"',"load_filename",'"'," under\nload_dir is directly loaded (the filename must include extension).\nIf only load_dir is set, get_latest_file() is called to seach the\nfolder for the file with the largest integer (index) in its filename,\nand returns that path for loading."),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Returns"),":"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"Checkpoint")," - Checkpointed states.")),(0,l.kt)("h4",{id:"get_latest_file"},"get","_","latest","_","file"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-python"},"@staticmethod\ndef get_latest_file(load_dir: str, file_prefix: str, file_ext: str = 'pt', logger=getlogger(__name__)) -> str\n")),(0,l.kt)("p",null,"Get the path to the last checkpointed file."),(0,l.kt)("p",null,"Find and return the path of the file with greatest number of\ncompleted epochs under dirpath (recursive search) for a given file\nprefix, and optionally file extension."),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Arguments"),":"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"load_dir")," ",(0,l.kt)("em",{parentName:"li"},"str")," - Directory under which to search for\ncheckpointed files."),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"file_prefix")," ",(0,l.kt)("em",{parentName:"li"},"str")," - Prefix to match for when searching\nfor candidate files."),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"file_ext")," ",(0,l.kt)("em",{parentName:"li"},"str, optional")," - File extension to consider\nwhen searching.")),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Returns"),":"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"str")," - Path to latest checkpointed file.")),(0,l.kt)("h4",{id:"check_mk_dir"},"check","_","mk","_","dir"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-python"},"def check_mk_dir(dirpath: str) -> None\n")),(0,l.kt)("p",null,"Check if the path exists, and if it doesn","'","t creates it."),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Arguments"),":"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"dirpath")," ",(0,l.kt)("em",{parentName:"li"},"str")," - Directory under which to search for\ncheckpointed files.")))}p.isMDXComponent=!0}}]);